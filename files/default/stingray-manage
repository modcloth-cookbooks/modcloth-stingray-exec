#!/usr/bin/env ruby

require 'fileutils'
require 'stingray/exec/dsl'
include Stingray::Exec::DSL

# NOTE: using p and n for pool and node to avoid namespace conflicts
def usage
  puts <<-EOB
    Usage: stingray-exec <action> <pool> <node>

    Valid actions: add_to_pool, add_and_drain, drain, undrain, disable, enable
  EOB
end

def main(action, p, n)
  valid_actions = %w(add_to_pool add_and_drain drain undrain disable enable)
  if valid_actions.include?(action)
    send(action.to_sym, p, n)
  else
    $stderr.puts "Invalid action: #{action}"
    usage
    exit 3
  end
end

def active_nodes(p)
  all_nodes = [*pool.get_nodes(p)[:nodes][:item][:item]]
  all_nodes -= disabled_nodes(p)
  all_nodes -= draining_nodes(p)
end

def disabled_nodes(p)
  disabled = pool.get_disabled_nodes(p)[:disabled_nodes][:item]
  if disabled.has_key?(:item)
    [*disabled[:item]]
  else
    []
  end
end

def draining_nodes(p)
  draining = pool.get_draining_nodes(p)[:values][:item]
  if draining.has_key?(:item)
    [*draining[:item]]
  else
    []
  end
end

def node_is_draining?(p, n)
  draining_nodes(p).include?(n)
end

def node_is_disabled?(p, n)
  disabled_nodes(p).include?(n)
end

def add_to_pool(p, n)
  pool.add_nodes(p => [n])
end

def add_and_drain(p, n)
  pool.add_nodes(p => [n])

  if node_should_fail_to_transition?(p, n)
    $stderr.puts "Refusing to drain #{n}, it is the only active node in the #{p} pool."
    FileUtils.touch(ENV['STINGRAY_FAILURE_FILE']) if ENV['STINGRAY_FAILURE_FILE']
  else
    pool.set_draining_nodes(p => [n]) unless node_is_disabled?(p, n)
  end
end

def node_should_fail_to_transition?(p, n)
  if node_is_disabled?(p, n) || node_is_draining?(p, n) || (active_nodes(p) - [n]).empty?
    true
  else
    false
  end
end

def drain(p, n)
  if node_should_fail_to_transition?(p, n)
    $stderr.puts "Refusing to drain #{n}, it is the only active node in the #{p} pool."
    FileUtils.touch(ENV['STINGRAY_FAILURE_FILE']) if ENV['STINGRAY_FAILURE_FILE']
  else
    pool.set_draining_nodes(p => [n]) unless node_is_disabled?(p, n)
  end
end

def undrain(p, n)
  pool.remove_draining_nodes(p => [n]) if node_is_draining?(p, n)
end

def disable(p, n)
  if node_should_fail_to_transition?(p, n)
    $stderr.puts "Refusing to disable node #{n}, it is the only active node in the #{p} pool."
    FileUtils.touch(ENV['STINGRAY_FAILURE_FILE']) if ENV['STINGRAY_FAILURE_FILE']
  elsif active_nodes(p).include?(n)
    pool.disable_nodes(p => [n])
  end
end

def enable(p, n)
  pool.enable_nodes(p => [n]) if node_is_disabled?(p, n)
end

if $0 == __FILE__
  if ARGV.count < 3
    $stderr.puts "Not enough args. Requires 3, got #{ARGV.count}"
    usage
    exit 2
  end

  main(ARGV[0], ARGV[1], ARGV[2])
end
